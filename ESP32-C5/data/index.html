<!doctype html>
<html>
    <head>
        <meta charset='utf-8'>
        <title>HandTool</title>
        <meta name="viewport" content="width=device-width,initial-scale=1">
        <style>body{font-family:Arial,Helvetica,sans-serif;margin:12px;}img{border:1px solid #ddd;padding:4px;background:#fff}</style>
    </head>
    <body>
        <h1>HandTool Web Server</h1>
        <p><img src="https://raw.githubusercontent.com/vgroenhuis/HandTool/refs/heads/main/pics/HandTool_500px.jpg" alt="HandTool" style="max-width:100%;height:auto;"></p>
        <h2>External links</h2>
        <p><a href="https://github.com/vgroenhuis/HandTool" target="_blank">github.com/vgroenhuis/HandTool</a> Github repository with CAD files, sources, manual and assembly instructions</p>
        <h2>Links on this device</h2>
        <p><a href="/index.html">/index.html</a> This page. Also accessible from <a href="/">/</a></p>
        <p><a href="/robotView.html">/robotView.html</a> Open Robot View (3D)</p>
        <p><a href="/allData">/allData</a> JSON structure with all available data</p>
        <p><a href="/angles">/angles</a> JSON structure with joint angles in degrees</p>
        <p><a href="/rawAdcValues">/rawAdcValues</a> JSON structure with raw ADC values</p>
        <p><a href="/fk">/fk</a> JSON structure with end-effector to robot coordinate transformation matrix</p>
        <h2>Joint angles (degrees)</h2>
        <div id="angles_deg">Loading...</div>
        <h2>Analog inputs (raw)</h2>
        <div id="adc_raw">Loading...</div>
        <h2>Analog inputs (filtered)</h2>
        <div id="adc_filtered">Loading...</div>

        <script>
            let fetchInterval = 50; // desired interval in ms
            let isRunning = true;

            async function fetchAllData(){
                try {
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 200);
                    const r = await fetch('/allData', { signal: controller.signal });
                    clearTimeout(timeoutId);
                    if(!r.ok) return;
                    const j = await r.json();

                    // joint angles
                    const elAngles = document.getElementById('angles_deg');
                    const elAdcRaw = document.getElementById('adc_raw');
                    const elAdcFiltered = document.getElementById('adc_filtered');
                    if (j.valid === false) {
                        elAngles.innerHTML = '<p style="color:#d00;font-weight:bold;">⚠️ MCP3008 not detected - Joint angles unavailable</p>';
                        elAdcRaw.innerHTML = '<p style="color:#d00;font-weight:bold;">⚠️ MCP3008 not detected - Raw ADC data unavailable</p>';
                        elAdcFiltered.innerHTML = '<p style="color:#d00;font-weight:bold;">⚠️ MCP3008 not detected - Filtered ADC data unavailable</p>';
                    } else {
                        let htmlAngles = '<ul>';
                        for(let i=0;i<6;i++) htmlAngles += `<li>J${i+1}: ${j.jointAngles[i]}</li>`;
                        htmlAngles += '</ul>';
                        elAngles.innerHTML = htmlAngles;

                        let htmlRaw = '<ul>';
                        for(let i=0;i<8;i++) htmlRaw += `<li>CH${i}: ${j.rawAdcValues[i]}</li>`;
                        htmlRaw += '</ul>';
                        elAdcRaw.innerHTML = htmlRaw;

                        let htmlFiltered = '<ul>';
                        for(let i=0;i<8;i++) htmlFiltered += `<li>CH${i}: ${j.filteredAdcValues[i]}</li>`;
                        htmlFiltered += '</ul>';
                        elAdcFiltered.innerHTML = htmlFiltered;
                    }
                } catch(e) {
                    console.error('Fetch error:', e);
                }
            }

            // Synchronous polling loop: wait for response before next request
            async function pollData() {
                while(isRunning) {
                    const start = Date.now();
                    await fetchAllData();
                    const elapsed = Date.now() - start;
                    // Wait for remaining interval time, or briefly if request took longer
                    const waitTime = Math.max(0, fetchInterval - elapsed);
                    await new Promise(resolve => setTimeout(resolve, waitTime));
                }
            }
            pollData();
        </script>
    </body>
</html>
